I"¨'<p><img src="/images/blog/erics/DSC_7772.jpg" alt="photo by eric wesseling" class="center-image" />
  <em>Photo By <a href="https://www.instagram.com/ericwess/">Eric Wesseling</a></em></p>

<h2 id="what-are-object-pools">What are object pools?</h2>

<p>Object pools are a design pattern that allows re-use of expensive objects. The point of an object pool is to avoid re-initializing expensive objects. Typically this works by creating an array to hold your objects then initializing, say 10 of them right up front. When you need one of these objects (like a database connection), you just grab it from the pool (<em>you check it out like a book at the library</em>) and when you are done you give it back.</p>

<p>This technique used to be much more common than it is now because machines used to have much less memory and in some languages the creation of objects was expensive. In Java this is no longer the case and you should almost always NOT use object pools because it is very cheap to initialize most objects.</p>

<h2 id="what-is-wrong-with-object-pools">What is wrong with object pools?</h2>

<p>The problem with object pools in modern Java apps is twofold: firstly objects are generally cheap to create and clean up negating the benefit of this design pattern, and secondly, it increases the old generation heap usage in way that the memory cannot ever be freed, thus increasing memory pressure and causing smaller more frequent garbage collection cycles (leading to more GC pauses and CPU usage).</p>

<p>There are also some more general issues with object pools (not just for Java apps). When you have an object pool you must make sure that two threads cannot use the same object the pool simultaneously, so now you must maintain synchronization. As we all know synchronization can be expensive and object pool access must synchronized across threads.</p>

<p>Finally, the last big problem with object pools is managing them alone requires some complexity and overhead. Even if you use a third part library like <a href="http://www.mchange.com/projects/c3p0/index.html"><strong>c3p0</strong></a> you will need to configure it correctly. As an example, an issue like this recently occurred at work where a project I was working on was having some performance issues. We realized we had copied some code from another team that created a connection pool with a very small number of connections and our application was having contention issues over getting connections from the pool. It took us a while to diagnose the issue, then locate this configuration parameter and bump it up.</p>

<h2 id="ok-when-should-i-use-them-in-java">OK, when should I use them in Java?</h2>

<p>Despite the downsides there actually are a couple of great places to use object pools. Some objects are long living and expensive to create, and these are great candidates for connection pooling. Database connections fall into this category and you will almost always see applications still using object pools to contain database connections for re-use.</p>

<p><strong>Here is a short of list of good objects to pool:</strong></p>

<ol>
  <li><strong>JDBC connections</strong> in general (as mentioned already).</li>
  <li><strong>Threads</strong>: Threads are expensive to create so Threadpools make a lot of sense</li>
  <li><strong>Large arrays</strong>: they can take a while to allocate since memory is reserved when you size them up front so it often makes sense the keep them around if you can spare the heap space.</li>
  <li><strong>Random + SecureRandom</strong> objects - these are expensive objects to create. SecureRandom grabs a list of Security Providers in the constructor, and the both must be seeded as well.</li>
  <li><strong>DNS lookups</strong> in general are slow and should be cached. Objects involved in this can be pooled.</li>
  <li>Various <strong>Encoders, Decoders, Serializers, Deserializers</strong>. A lot of these are either expensive to create or free because they may call some native code via JNI. Zip Encoders for example are expensive to GC for this reason.</li>
</ol>

<h2 id="what-else-can-i-use">What else can I use?</h2>

<p>Actually, for some of these scenarios, like encoders and decoders for example it makes a lot more sense to use ThreadLocal variables. This will allow you do less frequent creation of these objects while also avoiding the performance hit you take around having to synchronize thread pools. Most of these objects are also inherently not thread safe and in recent versions of Java calling ThreadLocal.get() is very fast so it makes sense to use this tool when you can.</p>

<p>It used to be that you had to worry about using ThreadLocals due issues around memory not getting freed when deploying and undeploying web app containers but this is a less common practice these days. You could end up with the infamous <code class="highlighter-rouge">java.lang.OutOfMemoryError: PermGen space</code>. But, with tools like Docker becoming much more popular it is no longer as common to run servlet containers as shared resources. It makes a lot more sense to use embedded Tomcat or embedded Jetty and run apps in stand-alone fashion. Check out the <a href="http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable">2nd answer on this stack overflow</a> for a discussion of these concerns.</p>

<h2 id="a-quick-example-of-using-a-connection-pool-in-java">A quick example of using a connection pool in Java</h2>

<p>In Java there are tons of great libraries that manage connection pools for you. In this example Iâ€™ll show  using <a href="http://www.mchange.com/projects/c3p0/index.html"><strong>c3p0</strong></a>. In this example I am initializing a new connection pool, setting the connection settings for Postgres, and then configuring the pool size. Finally, after initializing the pool I grab a connection from the pool.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.sql.Connection</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.mchange.v2.c3p0.ComboPooledDataSource</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CnxTest</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ComboPooledDataSource</span> <span class="n">cxnPool</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ComboPooledDataSource</span><span class="o">();</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

		<span class="c1">// config for local PG SQL instance</span>
		<span class="n">cxnPool</span><span class="o">.</span><span class="na">setDriverClass</span><span class="o">(</span> <span class="s">"org.postgresql.Driver"</span> <span class="o">);</span>
		<span class="n">cxnPool</span><span class="o">.</span><span class="na">setJdbcUrl</span><span class="o">(</span> <span class="s">"jdbc:postgresql://localhost/demos"</span> <span class="o">);</span>
		<span class="n">cxnPool</span><span class="o">.</span><span class="na">setUser</span><span class="o">(</span><span class="s">"postgres"</span><span class="o">);</span>
		<span class="n">cxnPool</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">"password"</span><span class="o">);</span>

		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Configuring the pool"</span><span class="o">);</span>
		<span class="c1">// set up pool size.</span>
		<span class="n">cxnPool</span><span class="o">.</span><span class="na">setMinPoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
		<span class="n">cxnPool</span><span class="o">.</span><span class="na">setAcquireIncrement</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
		<span class="n">cxnPool</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>

		<span class="c1">// actually using the pool:</span>
		<span class="nc">Connection</span> <span class="n">cxn</span> <span class="o">=</span> <span class="n">cxnPool</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>

		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DOne!"</span><span class="o">);</span>
	<span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>Here are the libraries I used to build this:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependencies&gt;</span>
	<span class="nt">&lt;dependency&gt;</span>
		<span class="nt">&lt;groupId&gt;</span>c3p0<span class="nt">&lt;/groupId&gt;</span>
		<span class="nt">&lt;artifactId&gt;</span>c3p0<span class="nt">&lt;/artifactId&gt;</span>
		<span class="nt">&lt;version&gt;</span>0.9.1.2<span class="nt">&lt;/version&gt;</span>
	<span class="nt">&lt;/dependency&gt;</span>
	<span class="c">&lt;!-- https://mvnrepository.com/artifact/org.postgresql/postgresql --&gt;</span>
	<span class="nt">&lt;dependency&gt;</span>
		<span class="nt">&lt;groupId&gt;</span>org.postgresql<span class="nt">&lt;/groupId&gt;</span>
		<span class="nt">&lt;artifactId&gt;</span>postgresql<span class="nt">&lt;/artifactId&gt;</span>
		<span class="nt">&lt;version&gt;</span>9.4.1212<span class="nt">&lt;/version&gt;</span>
	<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;/dependencies&gt;</span></code></pre></figure>

:ET