I"ñ<h3 id="mongodb-for-full-text-search-on-300k-items">MongoDB for full-text search on 300k items</h3>

<p>Recently I decided to use MongoDBâ€™s full-text search indexing feature for a dataset of about 300k products where I indexed the name of each item. On average I would say that the name fields were 200 to 300 chars and primarily simple english text. Overall I was very very impressed with the performance of MongoDB for this application - all of my test queries were easily sub-second on an EC2 t2.medium instance (which is 4 gb memory and 2 vCPUs at time of writing).</p>

<h3 id="oddly-mongodb-does-or-on-multi-word-queries">Oddly, MongoDB does â€˜ORâ€™ on multi-word queries</h3>

<p>So there are a few oddities in the default options when it comes to MongoDB fulltext search. First, the way you specify which fields on your collection to index is different in that there can only be one full text index on each collection. So while you can index multiple fields, there is only one index you can search on per collection.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// I am using Mongoose with Node</span>
<span class="c1">// example index:</span>
<span class="nx">MongooseModelToIndex</span><span class="p">.</span><span class="nx">index</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">text</span><span class="dl">'</span> <span class="p">});</span></code></pre></figure>

<p>As eluded to in the title of this section by default when search on the text index of a collection it will do an OR on each word so if you search â€˜Robots are coolâ€™ you will probably just get a bunch of results for â€˜coolâ€™ on the first few records. The way around this is to take into account textScore and sort on this:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Again, I'm using Mongoose with Node</span>
<span class="nx">MongooseModel</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span>
  <span class="p">{</span>
    <span class="dl">'</span><span class="s1">$text</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">$search</span><span class="dl">'</span><span class="p">:</span> <span class="nx">keyword</span>
    <span class="p">}</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="na">score</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">$meta</span><span class="p">:</span> <span class="dl">"</span><span class="s2">textScore</span><span class="dl">"</span>
    <span class="p">}</span>  
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">limit</span><span class="p">(</span><span class="nx">limit</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">sort</span><span class="p">({</span><span class="na">score</span><span class="p">:</span> <span class="p">{</span><span class="na">$meta</span><span class="p">:</span> <span class="dl">"</span><span class="s2">textScore</span><span class="dl">"</span><span class="p">}})</span>
  <span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">cb</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<p>Anyways, thatâ€™s all. Just wanted to record this peculiarity.</p>
:ET