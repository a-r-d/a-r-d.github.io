I"“<p>Earlier this week I was using the <a href="https://github.com/jasmine/jasmine">Jasmine testing framework</a> on some Angular code and wanted to use the spyOn feature to check that some of my service methods were getting called properly. ‚ÄúspyOn‚Äù, if you are not familiar is similar to a mock system in something like Jmock or Mockito (in the Java world). The spyOn method lets you observe a method on a given object where by default it will simply replace the method with a call counter that also traps a references to the calling arguments. If you call the spied on method you can later do something like:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">bar</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something with your arguments</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">spyOn</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// call the bar function on foo in some testing context.</span>
<span class="c1">// then, check it was called</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">bar</span><span class="p">).</span><span class="nx">toHaveBeenCalledWith</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span></code></pre></figure>

<p>This will assert the method was called with the argument ‚Äú123‚Äù (as a number of course). So be default the spy doesn‚Äôt actually call the method, if you want it to call the actual method and just count the call as it does it you will do something like this:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">spyOn</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">).</span><span class="nx">and</span><span class="p">.</span><span class="nx">callThrough</span><span class="p">()</span></code></pre></figure>

<p>This will cause the actual method to be called. This is very straightforward when you have arguments that are passed by value such as a number. However when you pass in an object (which is mutable) then you your expectation will be checking whatever the object referenced that may have mutated from what it was like when it was passed into the method you are spying on. So the problem is if I call foo.bar() with some object and I want to check that foo.bar() was called with the object I expect, what I really want in most cases I would argue is a deep copy of that object (i.e. a snapshot at that point in time)! I don‚Äôt want the mutated object after foo.bar() does some work on it.</p>

<p>So I want something like: ‚ÄúspyOn().and.callThrough({cloneArgs: true})‚Äù which tells ‚ÄúcallThrough‚Äù to clone those arguments when it records the call. I‚Äôm going to try to dig into the jasmine-core and see how easy it is to do something like this, although I don‚Äôt know how open the guys over at Pivotal labs are to contributions to Jasmine.</p>

<p>UPDATE:</p>

<p><a href="https://github.com/jasmine/jasmine/pull/1000">I submitted a pull request to Jasmine and it was accepted</a> which does a shallow clone. It is based off of <a href="https://github.com/jasmine/jasmine/issues/872#issuecomment-164467203">this issue</a></p>
:ET